/* eslint-disable */

import { createUmi } from '@metaplex-foundation/umi-bundle-defaults';
import { createSignerFromKeypair, signerIdentity, publicKey } from '@metaplex-foundation/umi';
import { fetchCandyMachine, updateCandyGuard, fetchCandyGuard } from '@metaplex-foundation/mpl-candy-machine';
import { some } from '@metaplex-foundation/umi';
import * as fs from 'fs';
import * as path from 'path';

const main = async () => {
    console.log("Initializing...");
    const umi = createUmi('https://api.devnet.solana.com');

    // Setup Wallet
    const walletPath = '/Users/srijonbiswas/.config/solana/id.json';
    if (!fs.existsSync(walletPath)) {
        throw new Error("Wallet not found at " + walletPath);
    }
    const wallet = JSON.parse(fs.readFileSync(walletPath, 'utf-8'));
    const keypair = umi.eddsa.createKeypairFromSecretKey(new Uint8Array(wallet));
    const signer = createSignerFromKeypair(umi, keypair);
    umi.use(signerIdentity(signer));

    console.log("Wallet:", signer.publicKey.toString());

    // Read Candy Machine ID from file (or use hardcoded if file missing as fallback)
    // We try to read the random one first as that seems to be the active one based on previous context
    let candyMachineIdString = process.env.NEXT_PUBLIC_CANDY_MACHINE_ID;
    
    // Try reading from file generated by deploy script
    if (fs.existsSync('candy_machine_id_random.txt')) {
        candyMachineIdString = fs.readFileSync('candy_machine_id_random.txt', 'utf-8').trim();
    }

    if (!candyMachineIdString) {
        throw new Error("Could not find Candy Machine ID (env or file)");
    }

    console.log("Candy Machine ID:", candyMachineIdString);
    const candyMachineId = publicKey(candyMachineIdString);

    // Fetch Candy Machine to get the Guard
    const candyMachine = await fetchCandyMachine(umi, candyMachineId);
    const candyGuardId = candyMachine.mintAuthority; 
    console.log("Candy Guard ID:", candyGuardId.toString());

    // Update the Guard to include MintLimit
    console.log("Updating Candy Guard to enable MintLimit (2 per wallet)...");

    // We keep existing guards (like solPayment) enabled if we want, 
    // but the `updateCandyGuard` function typically requires specifying the full new guards settings 
    // or it might overwrite. 
    // Best practice: Fetch existing guard settings if possible, or re-define our desired state.
    // For this task, we want strict 2 per wallet AND the payment we likely set up before.
    // Let's re-state the desired guards:
    // 1. SolPayment: 0.1 SOL (standard for this app)
    // 2. MintLimit: 2

    // Note: The previous deploy script set SolPayment to 0.1 SOL (100000000 lamports) to signer.
    
    await updateCandyGuard(umi, {
        candyGuard: candyGuardId,
        guards: {
            solPayment: some({
                lamports: { basisPoints: BigInt(100000000), identifier: 'SOL', decimals: 9 }, // 0.1 SOL
                destination: signer.publicKey,
            }),
            mintLimit: some({
                id: 1, // Unique ID for this limit
                limit: 2,
            }),
        },
        groups: [], // Clear any groups if they existed, or keep empty
    }).sendAndConfirm(umi);

    console.log("âœ… Candy Guard updated successfully!");
    console.log("Mint Limit set to 2 per wallet.");
};

main().catch(console.error);
